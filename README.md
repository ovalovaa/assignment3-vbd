метою цього завдання було продемонструвати, як різні рівні ізоляції транзакцій у MySQL впливають на узгодженість даних і конкурентність. Завдання зосереджені на таких аномаліях:

Dirty read
Non-repeatable read
Deadlock

Зпершу я створила маленьку табличку accounts та додала в неї тестові дані.

Dirty Read (READ UNCOMMITTED)
У першій частині я встановила рівень ізоляції READ UNCOMMITTED і відкрила дві сесії.
В одній з них виконала оновлення без коміту, а в іншій прочитала ці незакомічені дані.
З цієї частини я зробила висновок, що dirty read дійсно можливий на цьому рівні ізоляції, оскільки дозволяє бачити ще не підтверджені зміни інших транзакцій.

Non-Repeatable Read (READ COMMITTED)
У другій частині я використала READ COMMITTED. У першій сесії я двічі прочитала баланс, а в другій між цими двома запитами виконала оновлення і коміт.
З цієї частини я зробила висновок, що значення одного й того самого рядка може змінюватися в межах однієї транзакції, оскільки транзакція бачить нові коміти під час свого виконання. Це і є non-repeatable read.

Repeatable Read (REPEATABLE READ)
У бонусному завданні я використала REPEATABLE READ. Незважаючи на те, що інша транзакція оновила рядок і зробила коміт, моя транзакція бачила лише початкове значення.
З цієї частини я зробила висновок, що рівень REPEATABLE READ забезпечує послідовність читання — ті самі дані залишаються незмінними протягом всієї транзакції.READ COMMITTED дозволяє змінюватися даним під час транзакції — це може спричинити non-repeatable read.
REPEATABLE READ гарантує, що всі SELECT-и протягом однієї транзакції будуть повертати ті самі значення, навіть якщо інші транзакції в цей час змінюють дані.
Таким чином, REPEATABLE READ забезпечує вищу цілісність даних, але потенційно зменшує паралелізм

Deadlock 
У цьому завданні я створила ситуацію, коли дві транзакції намагалися оновити одні й ті самі рядки, але в різному порядку.
MySQL зафіксував взаємне блокування і автоматично скасував одну з транзакцій.
З цієї частини я зробила висновок, що deadlock виникає через конфлікт блокувань, і MySQL самостійно виявляє та розв’язує його, виводячи помилку Deadlock found.

Під час виконання цього завдання я на практиці побачила, як різні рівні ізоляції впливають на поведінку транзакцій, що підтвердило теоретичні знання про dirty read, non-repeatable read та deadlock.
